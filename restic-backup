#!/bin/bash

logfile=/var/log/restic-backup.log
errfile=/var/log/restic-backup.err

# Checks execution context: need to be root
checkroot()
{
    if [ `whoami` != "root" ]; then
	echo "$0 must be run as root" 1>&2
	exit 1
    fi
}

# Define path to restic executable
if [ `uname` == "Darwin" ]; then
	prog=/opt/local/bin/restic
else
	prog=/usr/bin/restic
fi

# Control variables - defaults
verbose="no"
check="yes"
quiet="yes"
dryrun="no"
nocache=--exclude-caches

# Command line options - see below in function help for details.
while getopts vnpd flag
do
    case "${flag}" in
	v) verbose="yes";;
	n) check="no";;
	p) quiet="no";;
	d) dryrun="yes";;
    esac
done
# adjust argument index to point to non-option arguments:
# $1 and $2 will point to them
shift $((OPTIND - 1))

# Check for verbose output: default no
if [ "$verbose" == "yes" ]; then
    verbose="--verbose=2"
else
    verbose=
fi

# Check for quiet execution of restic: default yes
if [ "$quiet" != "no" ]; then
    quiet="--quiet"
    verbose=
else
    quiet=
fi

# Check for dry-run
if [ "$dryrun" == "yes" ]; then
    dryrun=--dry-run
else
    dryrun=
fi

# Backup only for this name=`hostname`
name=`hostname`

# restic password
export RESTIC_PASSWORD_FILE=~/.resticpw

# Help function
help()
{
    echo "Backup to repository."
    echo
    echo "usage: restic-backup OPTIONS LOCATION TAG"
    echo "  OPTIONS:"
    echo "  -n	Do not check the respository after completion."
    echo "  -p	Show progress."
    echo "  -v	Be verbose."
    echo "  -d	Dry-run."
    echo
    echo "LOCATION:"
    echo "  lan       Backup to repo on local SFTP server."
    echo "  onedrive  Backup to repo on ONEDRIVE server."
    echo "  local     Backup to local repo."
    echo "  help      Print help."
    echo
    echo "TAG:"
    echo "  daily or weekly or any other user defined string"
}

# Log function
log()
{
    echo `date`": $1" >> $logfile
}

# What to include and exclude to or from  backup
include=restic-backup-include.conf
exclude=restic-backup-exclude.conf

if test -f /etc/$include; then
 	include=/etc/$include
 	exclude=/etc/$exclude;
else
 	include=.$include
 	exclude=.$exclude;
fi

# Can't work w/o include list
if ! test -f $include; then
	log "$include not found"
	exit 1;
fi

# Calculate repository
case "$1" in
    "lan")
	export RESTIC_REPOSITORY="sftp:"`whoami`"@raspberrypi2:/var/Backup/hebbie"
	;;
    "onedrive")
	export RESTIC_REPOSITORY="rclone:onedrive:backup/hebbie"
	;;
    "local")
	export RESTIC_REPOSITORY="/Volumes/BackupDisk/hebbie"
	;;
    "help")
	help
	exit 0
	;;
    *)
	help
	exit 1
	;;
esac

# Check execution context first.
checkroot

# We require the tag as second parameter
if [ "$2" == "" ]; then
    echo "Error: tag as second parameter required!"
    help
    exit 1
fi

# Perform backup
dobackup()
{
	# unlock repo	
	$prog unlock
	# execute
    	$prog backup $quiet $verbose $dryrun $nocache --tag $1 --files-from $include --exclude-file $exclude --exclude $RESTIC_PASSWORD_FILE
}

# Perform repository check
docheck()
{
    $prog unlock
    $prog check $quiet $verbose
}


log "$0: backup (restic) of $name to $RESTIC_REPOSITORY started."

# Backup
log "   Backing up to $RESTIC_REPOSITORY ..."

# This tricky thing captures stderr of dobackup in $err and maintains exit code in $? for evaluation
{ err="$( { dobackup $2; } 2>&1 1>&3 3>&- )"; } 3>&1

if [ $? -ne 0 ]; then
    echo $err 1>&2
    log "   $err" 
    log "$0: backup (restic) of $name to $RESTIC_REPOSITORY failed."
    exit 1
fi


# Check
if [ "$check" == "yes" ]; then
    log "   Checking $RESTIC_REPOSITORY ..."
    { err="$( { docheck; } 2>&1 1>&3 3>&- )"; } 3>&1
    if [ $? -ne 0 ]; then
	echo $err
	log "   $err" 
	log "$0: backup (restic) of $name to $RESTIC_REPOSITORY failed."
	exit 1
    fi
fi

log "$0: backup (restic) of $name to $RESTIC_REPOSITORY finished."
exit 0
